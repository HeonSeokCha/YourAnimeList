package com.chs.presentation.browse.animeimport androidx.compose.animation.animateContentSizeimport androidx.compose.animation.core.Springimport androidx.compose.animation.core.springimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.*import androidx.compose.foundation.lazy.LazyRowimport androidx.compose.foundation.lazy.itemsimport androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material.icons.Iconsimport androidx.compose.material.icons.filled.ArrowDownwardimport androidx.compose.material.icons.filled.Closeimport androidx.compose.material3.*import androidx.compose.runtime.*import androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.res.stringResourceimport androidx.compose.ui.text.AnnotatedStringimport androidx.compose.ui.text.font.FontWeightimport androidx.compose.ui.text.fromHtmlimport androidx.compose.ui.text.style.TextOverflowimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport com.chs.common.Resourceimport com.chs.domain.model.AnimeDetailInfoimport com.chs.domain.model.AnimeInfoimport com.chs.domain.model.AnimeRelationInfoimport com.chs.domain.model.AnimeThemeInfoimport com.chs.presentation.Rimport com.chs.presentation.UiConstimport com.chs.presentation.UiConst.GENRE_COLORimport com.chs.presentation.browse.BrowseScreenimport com.chs.presentation.colorimport com.chs.presentation.common.ItemAnimeSmallimport com.chs.presentation.common.PlaceholderHighlightimport com.chs.presentation.common.placeholderimport com.chs.presentation.common.shimmerimport com.chs.presentation.isNotEmptyValueimport com.chs.presentation.main.Screen@Composablefun AnimeOverViewScreen(    animeDetailState: Resource<AnimeDetailInfo>,    animeThemeState: Resource<AnimeThemeInfo>,    onClick: (Any) -> Unit) {    var expandedDescButton by remember { mutableStateOf(false) }    val scrollState = rememberScrollState()    Column(        modifier = Modifier            .fillMaxSize()            .padding(                start = 4.dp,                end = 8.dp,                bottom = 16.dp            )            .verticalScroll(scrollState)    ) {        when (animeDetailState) {            is Resource.Loading -> {                ItemLoading()            }            is Resource.Success -> {                val animeOverViewInfo = animeDetailState.data                AnimeGenreChips(animeOverViewInfo?.genres ?: List(3) { null }) {                    onClick(it)                }                AnimeDescription(                    description = animeOverViewInfo?.description,                    expandedDescButton = expandedDescButton                ) {                    expandedDescButton = !expandedDescButton                }                AnimeScoreInfo(animeDetailInfo = animeOverViewInfo)                AnimeSummaryInfo(animeOverViewInfo) {                    onClick(it)                }                ItemAnimeThemes(state = animeThemeState)                if (animeOverViewInfo?.animeRelationInfo != null) {                    AnimeRelationInfo(animeList = animeOverViewInfo.animeRelationInfo) {                        onClick(                            BrowseScreen.AnimeDetailScreen(                                id = it.id,                                idMal = it.idMal                            )                        )                    }                }            }            is Resource.Error -> {                Box(                    modifier = Modifier                        .fillMaxSize()                ) {                    Text(                        modifier = Modifier                            .align(Alignment.Center),                        text = animeDetailState.message.toString()                    )                }            }        }    }}@Composableprivate fun ItemAnimeThemes(state: Resource<AnimeThemeInfo>) {    when (state) {        is Resource.Loading -> {}        is Resource.Success -> {            val animeTheme = state.data            if (animeTheme?.openingThemes != null && animeTheme.openingThemes.isNotEmpty()) {                AnimeThemeInfo(                    title = "Opening Theme",                    songList = animeTheme.openingThemes                )            }            if (animeTheme?.endingThemes != null && animeTheme.endingThemes.isNotEmpty()) {                AnimeThemeInfo(                    title = "Ending Theme",                    songList = animeTheme.endingThemes                )            }        }        is Resource.Error -> {}    }}@Composableprivate fun ItemLoading() {    AnimeGenreChips(list = List(3) { null }) { }    AnimeDescription(description = null, expandedDescButton = false) {}    AnimeScoreInfo(animeDetailInfo = null)    AnimeSummaryInfo(null) {}    AnimeThemeInfo(        title = null,        songList = List(3) { null }    )    AnimeThemeInfo(        title = null,        songList = List(3) { null }    )}@OptIn(ExperimentalLayoutApi::class)@Composableprivate fun AnimeGenreChips(    list: List<String?>,    onClick: (Screen) -> Unit) {    var maxLines by remember { mutableIntStateOf(1) }    ContextualFlowRow(        modifier = Modifier            .animateContentSize(),        itemCount = list.count(),        maxLines = maxLines,        overflow = ContextualFlowRowOverflow.expandOrCollapseIndicator(            minRowsToShowCollapse = 2,            expandIndicator = {                TextButton(                    modifier = Modifier                        .padding(                            top = 4.dp,                            end = 4.dp                        ),                    onClick = { maxLines += 1 },                    colors = ButtonDefaults.textButtonColors(                        contentColor = MaterialTheme.colorScheme.surfaceVariant,                        containerColor = MaterialTheme.colorScheme.onSurface                    )                ) {                    Text(                        text = "${this@expandOrCollapseIndicator.totalItemCount - this@expandOrCollapseIndicator.shownItemCount}+ more"                    )                }            },            collapseIndicator = {                TextButton(                    modifier = Modifier                        .padding(                            top = 4.dp,                            end = 4.dp                        ),                    onClick = { maxLines = 1 },                    colors = ButtonDefaults.textButtonColors(                        contentColor = MaterialTheme.colorScheme.errorContainer,                        containerColor = MaterialTheme.colorScheme.error                    )                ) {                    Icon(                        modifier = Modifier.size(16.dp),                        imageVector = Icons.Default.Close,                        contentDescription = null                    )                    Text(text = "Hide")                }            }        ),        horizontalArrangement = Arrangement.spacedBy(8.dp)    ) { idx ->        val genre = list[idx]        AssistChip(            modifier = Modifier                .placeholder(                    visible = genre == null,                    highlight = PlaceholderHighlight.shimmer()                ),            onClick = {                onClick(Screen.SortListScreen(genre = genre))            }, label = {                Text(text = genre ?: "Unknown")            }, colors = AssistChipDefaults.assistChipColors(                containerColor = GENRE_COLOR[genre]?.color ?: Color.Black,                labelColor = Color.White            ), border = AssistChipDefaults.assistChipBorder(                enabled = true,                borderColor = GENRE_COLOR[genre]?.color ?: Color.Black            )        )    }}@Composableprivate fun AnimeThemeInfo(    title: String?,    songList: List<String?>) {    Column(        modifier = Modifier            .padding(                top = 8.dp,                bottom = 16.dp,                start = 4.dp            )    ) {        Text(            modifier = Modifier                .placeholder(                    visible = title == null,                    highlight = PlaceholderHighlight.shimmer()                ),            text = title ?: UiConst.TITLE_PREVIEW,            fontSize = 14.sp,            fontWeight = FontWeight.SemiBold        )        Spacer(modifier = Modifier.height(8.dp))        songList.forEach { themeTitle ->            Text(                modifier = Modifier                    .placeholder(                        visible = title == null,                        highlight = PlaceholderHighlight.shimmer()                    ),                text = themeTitle ?: UiConst.TITLE_PREVIEW,                fontSize = 13.sp            )        }    }}@Composableprivate fun AnimeRelationInfo(    animeList: List<AnimeRelationInfo>,    onClick: (animeInfo: AnimeInfo) -> Unit) {    LazyRow(        modifier = Modifier            .fillMaxWidth()            .wrapContentHeight(),        horizontalArrangement = Arrangement.spacedBy(4.dp),        contentPadding = PaddingValues(            start = 4.dp,            end = 8.dp,            bottom = 4.dp        )    ) {        items(            animeList,            key = { it.animeBasicInfo.id }        ) { animeInfo ->            ItemAnimeSmall(                item = animeInfo.animeBasicInfo            ) {                onClick(animeInfo.animeBasicInfo)            }        }    }}@Composableprivate fun AnimeSummaryInfo(    animeDetailInfo: AnimeDetailInfo?,    onClick: (Any) -> Unit) {    Column(        modifier = Modifier            .fillMaxWidth()            .wrapContentHeight()            .padding(                start = 4.dp,                bottom = 16.dp            )    ) {        AnimeSummaryInfoSmall("Romaji", animeDetailInfo?.animeInfo?.title)        AnimeSummaryInfoSmall("English", animeDetailInfo?.titleEnglish)        AnimeSummaryInfoSmall("Native", animeDetailInfo?.titleNative)        AnimeSummaryInfoSmall("Format", animeDetailInfo?.animeInfo?.format)        if (animeDetailInfo?.episode.isNotEmptyValue) {            AnimeSummaryInfoSmall("Episode", "${animeDetailInfo?.episode}Ep")        }        if (animeDetailInfo?.duration.isNotEmptyValue) {            AnimeSummaryInfoSmall("Durations", "${animeDetailInfo?.duration ?: 0}Min")        }        if (animeDetailInfo?.startDate.isNotEmptyValue) {            AnimeSummaryInfoSmall("StartDate", animeDetailInfo?.startDate)        }        if (animeDetailInfo?.endDate.isNotEmptyValue) {            AnimeSummaryInfoSmall("EndDate", animeDetailInfo?.endDate)        }        if (animeDetailInfo != null && animeDetailInfo.animeInfo.seasonYear != 0) {            AnimeSummaryInfoSmall(                "Season",                "${animeDetailInfo.animeInfo.seasonYear} ${animeDetailInfo.animeInfo.season}",                color = animeDetailInfo.animeInfo.imagePlaceColor?.color            ) {                onClick(                    Screen.SortListScreen(                        year = animeDetailInfo.animeInfo.seasonYear,                        season = animeDetailInfo.animeInfo.season                    )                )            }        }        if (animeDetailInfo != null && animeDetailInfo.studioInfo?.id.isNotEmptyValue) {            AnimeSummaryInfoSmall(                "Studio",                animeDetailInfo.studioInfo!!.name,                color = animeDetailInfo.animeInfo.imagePlaceColor?.color            ) {                onClick(                    BrowseScreen.StudioDetailScreen(id = animeDetailInfo.studioInfo!!.id)                )            }        }    }}@Composableprivate fun AnimeSummaryInfoSmall(    title: String,    value: String?,    color: Color? = null,    onClick: () -> Unit = { }) {    Row(        modifier = Modifier            .fillMaxWidth()            .padding(horizontal = 4.dp, vertical = 8.dp)    ) {        Text(            text = "$title : ",            fontWeight = FontWeight.Bold,            fontSize = 14.sp,        )        Spacer(modifier = Modifier.weight(1f))        Text(            modifier = Modifier                .clickable { onClick() },            text = value ?: "Unknown",            fontWeight = FontWeight.Bold,            fontSize = 14.sp,            color = color ?: Color.Black        )    }}@Composableprivate fun AnimeScoreInfo(animeDetailInfo: AnimeDetailInfo?) {    Row(        modifier = Modifier            .fillMaxWidth()            .wrapContentHeight()            .padding(                top = 16.dp,                bottom = 16.dp            ),        horizontalArrangement = Arrangement.SpaceAround    ) {        val summaryList = listOf(            "Average" to "${animeDetailInfo?.animeInfo?.averageScore ?: 0}%",            "Mean" to "${animeDetailInfo?.meanScore ?: 0}%",            "Popularity" to "${animeDetailInfo?.popularScore ?: 0}",            "Favourites" to "${animeDetailInfo?.animeInfo?.favourites ?: 0}"        )        summaryList.forEach {            Column(                horizontalAlignment = Alignment.CenterHorizontally            ) {                Text(                    modifier = Modifier                        .placeholder(                            visible = animeDetailInfo == null,                            highlight = PlaceholderHighlight.shimmer()                        ),                    text = it.second,                    fontSize = 14.sp,                    fontWeight = FontWeight.SemiBold                )                Text(                    modifier = Modifier                        .placeholder(                            visible = animeDetailInfo == null,                            highlight = PlaceholderHighlight.shimmer()                        ),                    text = it.first,                    fontSize = 14.sp,                    fontWeight = FontWeight.SemiBold                )            }        }    }}@Composableprivate fun AnimeDescription(    description: String?,    expandedDescButton: Boolean,    onClick: () -> Unit) {    Column(        modifier = Modifier            .padding(                top = 8.dp,                bottom = 8.dp,                start = 4.dp            )            .animateContentSize(                animationSpec = spring(                    dampingRatio = Spring.DampingRatioMediumBouncy,                    stiffness = Spring.StiffnessLow                )            ),        horizontalAlignment = Alignment.CenterHorizontally    ) {        val spannedText = AnnotatedString.fromHtml(            description ?: stringResource(id = R.string.lorem_ipsum)        )        if (expandedDescButton) {            Text(                modifier = Modifier                    .placeholder(                        visible = description == null,                        highlight = PlaceholderHighlight.shimmer()                    ),                text = spannedText,                fontSize = 16.sp            )        } else {            Text(                modifier = Modifier                    .placeholder(                        visible = description == null,                        highlight = PlaceholderHighlight.shimmer()                    ),                text = spannedText,                fontSize = 16.sp,                maxLines = 5,                overflow = TextOverflow.Ellipsis            )        }        if (description != null && description.length > 300) {            if (!expandedDescButton) {                Button(                    modifier = Modifier                        .padding(                            top = 8.dp,                            bottom = 8.dp                        ),                    onClick = { onClick() }                ) {                    Icon(                        imageVector = Icons.Filled.ArrowDownward,                        contentDescription = null                    )                }            }        }    }}